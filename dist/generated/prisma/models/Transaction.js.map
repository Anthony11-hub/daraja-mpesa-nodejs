{"version":3,"file":"Transaction.js","sourceRoot":"/","sources":["generated/prisma/models/Transaction.ts"],"names":[],"mappings":"","sourcesContent":["\n/* !!! This is code generated by Prisma. Do not edit directly. !!! */\n/* eslint-disable */\n// biome-ignore-all lint: generated file\n// @ts-nocheck \n/*\n * This file exports the `Transaction` model and its related types.\n *\n * ðŸŸ¢ You can import this file directly.\n */\nimport type * as runtime from \"@prisma/client/runtime/client\"\nimport type * as $Enums from \"../enums\"\nimport type * as Prisma from \"../internal/prismaNamespace\"\n\n/**\n * Model Transaction\n * \n */\nexport type TransactionModel = runtime.Types.Result.DefaultSelection<Prisma.$TransactionPayload>\n\nexport type AggregateTransaction = {\n  _count: TransactionCountAggregateOutputType | null\n  _avg: TransactionAvgAggregateOutputType | null\n  _sum: TransactionSumAggregateOutputType | null\n  _min: TransactionMinAggregateOutputType | null\n  _max: TransactionMaxAggregateOutputType | null\n}\n\nexport type TransactionAvgAggregateOutputType = {\n  amount: number | null\n}\n\nexport type TransactionSumAggregateOutputType = {\n  amount: number | null\n}\n\nexport type TransactionMinAggregateOutputType = {\n  id: string | null\n  paymentRef: string | null\n  amount: number | null\n  phone: string | null\n  status: $Enums.txnStatus | null\n  mpesaRef: string | null\n  checkoutRequestId: string | null\n  createdAt: Date | null\n  updatedAt: Date | null\n}\n\nexport type TransactionMaxAggregateOutputType = {\n  id: string | null\n  paymentRef: string | null\n  amount: number | null\n  phone: string | null\n  status: $Enums.txnStatus | null\n  mpesaRef: string | null\n  checkoutRequestId: string | null\n  createdAt: Date | null\n  updatedAt: Date | null\n}\n\nexport type TransactionCountAggregateOutputType = {\n  id: number\n  paymentRef: number\n  amount: number\n  phone: number\n  status: number\n  mpesaRef: number\n  checkoutRequestId: number\n  createdAt: number\n  updatedAt: number\n  _all: number\n}\n\n\nexport type TransactionAvgAggregateInputType = {\n  amount?: true\n}\n\nexport type TransactionSumAggregateInputType = {\n  amount?: true\n}\n\nexport type TransactionMinAggregateInputType = {\n  id?: true\n  paymentRef?: true\n  amount?: true\n  phone?: true\n  status?: true\n  mpesaRef?: true\n  checkoutRequestId?: true\n  createdAt?: true\n  updatedAt?: true\n}\n\nexport type TransactionMaxAggregateInputType = {\n  id?: true\n  paymentRef?: true\n  amount?: true\n  phone?: true\n  status?: true\n  mpesaRef?: true\n  checkoutRequestId?: true\n  createdAt?: true\n  updatedAt?: true\n}\n\nexport type TransactionCountAggregateInputType = {\n  id?: true\n  paymentRef?: true\n  amount?: true\n  phone?: true\n  status?: true\n  mpesaRef?: true\n  checkoutRequestId?: true\n  createdAt?: true\n  updatedAt?: true\n  _all?: true\n}\n\nexport type TransactionAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {\n  /**\n   * Filter which Transaction to aggregate.\n   */\n  where?: Prisma.TransactionWhereInput\n  /**\n   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n   * \n   * Determine the order of Transactions to fetch.\n   */\n  orderBy?: Prisma.TransactionOrderByWithRelationInput | Prisma.TransactionOrderByWithRelationInput[]\n  /**\n   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n   * \n   * Sets the start position\n   */\n  cursor?: Prisma.TransactionWhereUniqueInput\n  /**\n   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n   * \n   * Take `Â±n` Transactions from the position of the cursor.\n   */\n  take?: number\n  /**\n   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n   * \n   * Skip the first `n` Transactions.\n   */\n  skip?: number\n  /**\n   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n   * \n   * Count returned Transactions\n  **/\n  _count?: true | TransactionCountAggregateInputType\n  /**\n   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n   * \n   * Select which fields to average\n  **/\n  _avg?: TransactionAvgAggregateInputType\n  /**\n   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n   * \n   * Select which fields to sum\n  **/\n  _sum?: TransactionSumAggregateInputType\n  /**\n   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n   * \n   * Select which fields to find the minimum value\n  **/\n  _min?: TransactionMinAggregateInputType\n  /**\n   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n   * \n   * Select which fields to find the maximum value\n  **/\n  _max?: TransactionMaxAggregateInputType\n}\n\nexport type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {\n      [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'\n    ? T[P] extends true\n      ? number\n      : Prisma.GetScalarType<T[P], AggregateTransaction[P]>\n    : Prisma.GetScalarType<T[P], AggregateTransaction[P]>\n}\n\n\n\n\nexport type TransactionGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {\n  where?: Prisma.TransactionWhereInput\n  orderBy?: Prisma.TransactionOrderByWithAggregationInput | Prisma.TransactionOrderByWithAggregationInput[]\n  by: Prisma.TransactionScalarFieldEnum[] | Prisma.TransactionScalarFieldEnum\n  having?: Prisma.TransactionScalarWhereWithAggregatesInput\n  take?: number\n  skip?: number\n  _count?: TransactionCountAggregateInputType | true\n  _avg?: TransactionAvgAggregateInputType\n  _sum?: TransactionSumAggregateInputType\n  _min?: TransactionMinAggregateInputType\n  _max?: TransactionMaxAggregateInputType\n}\n\nexport type TransactionGroupByOutputType = {\n  id: string\n  paymentRef: string\n  amount: number\n  phone: string\n  status: $Enums.txnStatus\n  mpesaRef: string | null\n  checkoutRequestId: string\n  createdAt: Date\n  updatedAt: Date\n  _count: TransactionCountAggregateOutputType | null\n  _avg: TransactionAvgAggregateOutputType | null\n  _sum: TransactionSumAggregateOutputType | null\n  _min: TransactionMinAggregateOutputType | null\n  _max: TransactionMaxAggregateOutputType | null\n}\n\ntype GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<\n  Array<\n    Prisma.PickEnumerable<TransactionGroupByOutputType, T['by']> &\n      {\n        [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'\n          ? T[P] extends boolean\n            ? number\n            : Prisma.GetScalarType<T[P], TransactionGroupByOutputType[P]>\n          : Prisma.GetScalarType<T[P], TransactionGroupByOutputType[P]>\n      }\n    >\n  >\n\n\n\nexport type TransactionWhereInput = {\n  AND?: Prisma.TransactionWhereInput | Prisma.TransactionWhereInput[]\n  OR?: Prisma.TransactionWhereInput[]\n  NOT?: Prisma.TransactionWhereInput | Prisma.TransactionWhereInput[]\n  id?: Prisma.StringFilter<\"Transaction\"> | string\n  paymentRef?: Prisma.StringFilter<\"Transaction\"> | string\n  amount?: Prisma.FloatFilter<\"Transaction\"> | number\n  phone?: Prisma.StringFilter<\"Transaction\"> | string\n  status?: Prisma.EnumtxnStatusFilter<\"Transaction\"> | $Enums.txnStatus\n  mpesaRef?: Prisma.StringNullableFilter<\"Transaction\"> | string | null\n  checkoutRequestId?: Prisma.StringFilter<\"Transaction\"> | string\n  createdAt?: Prisma.DateTimeFilter<\"Transaction\"> | Date | string\n  updatedAt?: Prisma.DateTimeFilter<\"Transaction\"> | Date | string\n}\n\nexport type TransactionOrderByWithRelationInput = {\n  id?: Prisma.SortOrder\n  paymentRef?: Prisma.SortOrder\n  amount?: Prisma.SortOrder\n  phone?: Prisma.SortOrder\n  status?: Prisma.SortOrder\n  mpesaRef?: Prisma.SortOrderInput | Prisma.SortOrder\n  checkoutRequestId?: Prisma.SortOrder\n  createdAt?: Prisma.SortOrder\n  updatedAt?: Prisma.SortOrder\n  _relevance?: Prisma.TransactionOrderByRelevanceInput\n}\n\nexport type TransactionWhereUniqueInput = Prisma.AtLeast<{\n  id?: string\n  paymentRef?: string\n  AND?: Prisma.TransactionWhereInput | Prisma.TransactionWhereInput[]\n  OR?: Prisma.TransactionWhereInput[]\n  NOT?: Prisma.TransactionWhereInput | Prisma.TransactionWhereInput[]\n  amount?: Prisma.FloatFilter<\"Transaction\"> | number\n  phone?: Prisma.StringFilter<\"Transaction\"> | string\n  status?: Prisma.EnumtxnStatusFilter<\"Transaction\"> | $Enums.txnStatus\n  mpesaRef?: Prisma.StringNullableFilter<\"Transaction\"> | string | null\n  checkoutRequestId?: Prisma.StringFilter<\"Transaction\"> | string\n  createdAt?: Prisma.DateTimeFilter<\"Transaction\"> | Date | string\n  updatedAt?: Prisma.DateTimeFilter<\"Transaction\"> | Date | string\n}, \"id\" | \"paymentRef\">\n\nexport type TransactionOrderByWithAggregationInput = {\n  id?: Prisma.SortOrder\n  paymentRef?: Prisma.SortOrder\n  amount?: Prisma.SortOrder\n  phone?: Prisma.SortOrder\n  status?: Prisma.SortOrder\n  mpesaRef?: Prisma.SortOrderInput | Prisma.SortOrder\n  checkoutRequestId?: Prisma.SortOrder\n  createdAt?: Prisma.SortOrder\n  updatedAt?: Prisma.SortOrder\n  _count?: Prisma.TransactionCountOrderByAggregateInput\n  _avg?: Prisma.TransactionAvgOrderByAggregateInput\n  _max?: Prisma.TransactionMaxOrderByAggregateInput\n  _min?: Prisma.TransactionMinOrderByAggregateInput\n  _sum?: Prisma.TransactionSumOrderByAggregateInput\n}\n\nexport type TransactionScalarWhereWithAggregatesInput = {\n  AND?: Prisma.TransactionScalarWhereWithAggregatesInput | Prisma.TransactionScalarWhereWithAggregatesInput[]\n  OR?: Prisma.TransactionScalarWhereWithAggregatesInput[]\n  NOT?: Prisma.TransactionScalarWhereWithAggregatesInput | Prisma.TransactionScalarWhereWithAggregatesInput[]\n  id?: Prisma.StringWithAggregatesFilter<\"Transaction\"> | string\n  paymentRef?: Prisma.StringWithAggregatesFilter<\"Transaction\"> | string\n  amount?: Prisma.FloatWithAggregatesFilter<\"Transaction\"> | number\n  phone?: Prisma.StringWithAggregatesFilter<\"Transaction\"> | string\n  status?: Prisma.EnumtxnStatusWithAggregatesFilter<\"Transaction\"> | $Enums.txnStatus\n  mpesaRef?: Prisma.StringNullableWithAggregatesFilter<\"Transaction\"> | string | null\n  checkoutRequestId?: Prisma.StringWithAggregatesFilter<\"Transaction\"> | string\n  createdAt?: Prisma.DateTimeWithAggregatesFilter<\"Transaction\"> | Date | string\n  updatedAt?: Prisma.DateTimeWithAggregatesFilter<\"Transaction\"> | Date | string\n}\n\nexport type TransactionCreateInput = {\n  id?: string\n  paymentRef: string\n  amount: number\n  phone: string\n  status?: $Enums.txnStatus\n  mpesaRef?: string | null\n  checkoutRequestId: string\n  createdAt?: Date | string\n  updatedAt?: Date | string\n}\n\nexport type TransactionUncheckedCreateInput = {\n  id?: string\n  paymentRef: string\n  amount: number\n  phone: string\n  status?: $Enums.txnStatus\n  mpesaRef?: string | null\n  checkoutRequestId: string\n  createdAt?: Date | string\n  updatedAt?: Date | string\n}\n\nexport type TransactionUpdateInput = {\n  id?: Prisma.StringFieldUpdateOperationsInput | string\n  paymentRef?: Prisma.StringFieldUpdateOperationsInput | string\n  amount?: Prisma.FloatFieldUpdateOperationsInput | number\n  phone?: Prisma.StringFieldUpdateOperationsInput | string\n  status?: Prisma.EnumtxnStatusFieldUpdateOperationsInput | $Enums.txnStatus\n  mpesaRef?: Prisma.NullableStringFieldUpdateOperationsInput | string | null\n  checkoutRequestId?: Prisma.StringFieldUpdateOperationsInput | string\n  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string\n  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string\n}\n\nexport type TransactionUncheckedUpdateInput = {\n  id?: Prisma.StringFieldUpdateOperationsInput | string\n  paymentRef?: Prisma.StringFieldUpdateOperationsInput | string\n  amount?: Prisma.FloatFieldUpdateOperationsInput | number\n  phone?: Prisma.StringFieldUpdateOperationsInput | string\n  status?: Prisma.EnumtxnStatusFieldUpdateOperationsInput | $Enums.txnStatus\n  mpesaRef?: Prisma.NullableStringFieldUpdateOperationsInput | string | null\n  checkoutRequestId?: Prisma.StringFieldUpdateOperationsInput | string\n  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string\n  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string\n}\n\nexport type TransactionCreateManyInput = {\n  id?: string\n  paymentRef: string\n  amount: number\n  phone: string\n  status?: $Enums.txnStatus\n  mpesaRef?: string | null\n  checkoutRequestId: string\n  createdAt?: Date | string\n  updatedAt?: Date | string\n}\n\nexport type TransactionUpdateManyMutationInput = {\n  id?: Prisma.StringFieldUpdateOperationsInput | string\n  paymentRef?: Prisma.StringFieldUpdateOperationsInput | string\n  amount?: Prisma.FloatFieldUpdateOperationsInput | number\n  phone?: Prisma.StringFieldUpdateOperationsInput | string\n  status?: Prisma.EnumtxnStatusFieldUpdateOperationsInput | $Enums.txnStatus\n  mpesaRef?: Prisma.NullableStringFieldUpdateOperationsInput | string | null\n  checkoutRequestId?: Prisma.StringFieldUpdateOperationsInput | string\n  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string\n  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string\n}\n\nexport type TransactionUncheckedUpdateManyInput = {\n  id?: Prisma.StringFieldUpdateOperationsInput | string\n  paymentRef?: Prisma.StringFieldUpdateOperationsInput | string\n  amount?: Prisma.FloatFieldUpdateOperationsInput | number\n  phone?: Prisma.StringFieldUpdateOperationsInput | string\n  status?: Prisma.EnumtxnStatusFieldUpdateOperationsInput | $Enums.txnStatus\n  mpesaRef?: Prisma.NullableStringFieldUpdateOperationsInput | string | null\n  checkoutRequestId?: Prisma.StringFieldUpdateOperationsInput | string\n  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string\n  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string\n}\n\nexport type TransactionOrderByRelevanceInput = {\n  fields: Prisma.TransactionOrderByRelevanceFieldEnum | Prisma.TransactionOrderByRelevanceFieldEnum[]\n  sort: Prisma.SortOrder\n  search: string\n}\n\nexport type TransactionCountOrderByAggregateInput = {\n  id?: Prisma.SortOrder\n  paymentRef?: Prisma.SortOrder\n  amount?: Prisma.SortOrder\n  phone?: Prisma.SortOrder\n  status?: Prisma.SortOrder\n  mpesaRef?: Prisma.SortOrder\n  checkoutRequestId?: Prisma.SortOrder\n  createdAt?: Prisma.SortOrder\n  updatedAt?: Prisma.SortOrder\n}\n\nexport type TransactionAvgOrderByAggregateInput = {\n  amount?: Prisma.SortOrder\n}\n\nexport type TransactionMaxOrderByAggregateInput = {\n  id?: Prisma.SortOrder\n  paymentRef?: Prisma.SortOrder\n  amount?: Prisma.SortOrder\n  phone?: Prisma.SortOrder\n  status?: Prisma.SortOrder\n  mpesaRef?: Prisma.SortOrder\n  checkoutRequestId?: Prisma.SortOrder\n  createdAt?: Prisma.SortOrder\n  updatedAt?: Prisma.SortOrder\n}\n\nexport type TransactionMinOrderByAggregateInput = {\n  id?: Prisma.SortOrder\n  paymentRef?: Prisma.SortOrder\n  amount?: Prisma.SortOrder\n  phone?: Prisma.SortOrder\n  status?: Prisma.SortOrder\n  mpesaRef?: Prisma.SortOrder\n  checkoutRequestId?: Prisma.SortOrder\n  createdAt?: Prisma.SortOrder\n  updatedAt?: Prisma.SortOrder\n}\n\nexport type TransactionSumOrderByAggregateInput = {\n  amount?: Prisma.SortOrder\n}\n\nexport type StringFieldUpdateOperationsInput = {\n  set?: string\n}\n\nexport type FloatFieldUpdateOperationsInput = {\n  set?: number\n  increment?: number\n  decrement?: number\n  multiply?: number\n  divide?: number\n}\n\nexport type EnumtxnStatusFieldUpdateOperationsInput = {\n  set?: $Enums.txnStatus\n}\n\nexport type NullableStringFieldUpdateOperationsInput = {\n  set?: string | null\n}\n\nexport type DateTimeFieldUpdateOperationsInput = {\n  set?: Date | string\n}\n\n\n\nexport type TransactionSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{\n  id?: boolean\n  paymentRef?: boolean\n  amount?: boolean\n  phone?: boolean\n  status?: boolean\n  mpesaRef?: boolean\n  checkoutRequestId?: boolean\n  createdAt?: boolean\n  updatedAt?: boolean\n}, ExtArgs[\"result\"][\"transaction\"]>\n\n\n\nexport type TransactionSelectScalar = {\n  id?: boolean\n  paymentRef?: boolean\n  amount?: boolean\n  phone?: boolean\n  status?: boolean\n  mpesaRef?: boolean\n  checkoutRequestId?: boolean\n  createdAt?: boolean\n  updatedAt?: boolean\n}\n\nexport type TransactionOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<\"id\" | \"paymentRef\" | \"amount\" | \"phone\" | \"status\" | \"mpesaRef\" | \"checkoutRequestId\" | \"createdAt\" | \"updatedAt\", ExtArgs[\"result\"][\"transaction\"]>\n\nexport type $TransactionPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {\n  name: \"Transaction\"\n  objects: {}\n  scalars: runtime.Types.Extensions.GetPayloadResult<{\n    id: string\n    paymentRef: string\n    amount: number\n    phone: string\n    status: $Enums.txnStatus\n    mpesaRef: string | null\n    checkoutRequestId: string\n    createdAt: Date\n    updatedAt: Date\n  }, ExtArgs[\"result\"][\"transaction\"]>\n  composites: {}\n}\n\nexport type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$TransactionPayload, S>\n\nexport type TransactionCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =\n  Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n    select?: TransactionCountAggregateInputType | true\n  }\n\nexport interface TransactionDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }\n  /**\n   * Find zero or one Transaction that matches the filter.\n   * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction\n   * @example\n   * // Get one Transaction\n   * const transaction = await prisma.transaction.findUnique({\n   *   where: {\n   *     // ... provide filter here\n   *   }\n   * })\n   */\n  findUnique<T extends TransactionFindUniqueArgs>(args: Prisma.SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma.Prisma__TransactionClient<runtime.Types.Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n  /**\n   * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`\n   * if no matches were found.\n   * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction\n   * @example\n   * // Get one Transaction\n   * const transaction = await prisma.transaction.findUniqueOrThrow({\n   *   where: {\n   *     // ... provide filter here\n   *   }\n   * })\n   */\n  findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__TransactionClient<runtime.Types.Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n  /**\n   * Find the first Transaction that matches the filter.\n   * Note, that providing `undefined` is treated as the value not being there.\n   * Read more here: https://pris.ly/d/null-undefined\n   * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction\n   * @example\n   * // Get one Transaction\n   * const transaction = await prisma.transaction.findFirst({\n   *   where: {\n   *     // ... provide filter here\n   *   }\n   * })\n   */\n  findFirst<T extends TransactionFindFirstArgs>(args?: Prisma.SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma.Prisma__TransactionClient<runtime.Types.Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n  /**\n   * Find the first Transaction that matches the filter or\n   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n   * Note, that providing `undefined` is treated as the value not being there.\n   * Read more here: https://pris.ly/d/null-undefined\n   * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction\n   * @example\n   * // Get one Transaction\n   * const transaction = await prisma.transaction.findFirstOrThrow({\n   *   where: {\n   *     // ... provide filter here\n   *   }\n   * })\n   */\n  findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__TransactionClient<runtime.Types.Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n  /**\n   * Find zero or more Transactions that matches the filter.\n   * Note, that providing `undefined` is treated as the value not being there.\n   * Read more here: https://pris.ly/d/null-undefined\n   * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.\n   * @example\n   * // Get all Transactions\n   * const transactions = await prisma.transaction.findMany()\n   * \n   * // Get first 10 Transactions\n   * const transactions = await prisma.transaction.findMany({ take: 10 })\n   * \n   * // Only select the `id`\n   * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })\n   * \n   */\n  findMany<T extends TransactionFindManyArgs>(args?: Prisma.SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n  /**\n   * Create a Transaction.\n   * @param {TransactionCreateArgs} args - Arguments to create a Transaction.\n   * @example\n   * // Create one Transaction\n   * const Transaction = await prisma.transaction.create({\n   *   data: {\n   *     // ... data to create a Transaction\n   *   }\n   * })\n   * \n   */\n  create<T extends TransactionCreateArgs>(args: Prisma.SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma.Prisma__TransactionClient<runtime.Types.Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n  /**\n   * Create many Transactions.\n   * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.\n   * @example\n   * // Create many Transactions\n   * const transaction = await prisma.transaction.createMany({\n   *   data: [\n   *     // ... provide data here\n   *   ]\n   * })\n   *     \n   */\n  createMany<T extends TransactionCreateManyArgs>(args?: Prisma.SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>\n\n  /**\n   * Delete a Transaction.\n   * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.\n   * @example\n   * // Delete one Transaction\n   * const Transaction = await prisma.transaction.delete({\n   *   where: {\n   *     // ... filter to delete one Transaction\n   *   }\n   * })\n   * \n   */\n  delete<T extends TransactionDeleteArgs>(args: Prisma.SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma.Prisma__TransactionClient<runtime.Types.Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n  /**\n   * Update one Transaction.\n   * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.\n   * @example\n   * // Update one Transaction\n   * const transaction = await prisma.transaction.update({\n   *   where: {\n   *     // ... provide filter here\n   *   },\n   *   data: {\n   *     // ... provide data here\n   *   }\n   * })\n   * \n   */\n  update<T extends TransactionUpdateArgs>(args: Prisma.SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma.Prisma__TransactionClient<runtime.Types.Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n  /**\n   * Delete zero or more Transactions.\n   * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.\n   * @example\n   * // Delete a few Transactions\n   * const { count } = await prisma.transaction.deleteMany({\n   *   where: {\n   *     // ... provide filter here\n   *   }\n   * })\n   * \n   */\n  deleteMany<T extends TransactionDeleteManyArgs>(args?: Prisma.SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>\n\n  /**\n   * Update zero or more Transactions.\n   * Note, that providing `undefined` is treated as the value not being there.\n   * Read more here: https://pris.ly/d/null-undefined\n   * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.\n   * @example\n   * // Update many Transactions\n   * const transaction = await prisma.transaction.updateMany({\n   *   where: {\n   *     // ... provide filter here\n   *   },\n   *   data: {\n   *     // ... provide data here\n   *   }\n   * })\n   * \n   */\n  updateMany<T extends TransactionUpdateManyArgs>(args: Prisma.SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>\n\n  /**\n   * Create or update one Transaction.\n   * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.\n   * @example\n   * // Update or create a Transaction\n   * const transaction = await prisma.transaction.upsert({\n   *   create: {\n   *     // ... data to create a Transaction\n   *   },\n   *   update: {\n   *     // ... in case it already exists, update\n   *   },\n   *   where: {\n   *     // ... the filter for the Transaction we want to update\n   *   }\n   * })\n   */\n  upsert<T extends TransactionUpsertArgs>(args: Prisma.SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma.Prisma__TransactionClient<runtime.Types.Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n  /**\n   * Count the number of Transactions.\n   * Note, that providing `undefined` is treated as the value not being there.\n   * Read more here: https://pris.ly/d/null-undefined\n   * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.\n   * @example\n   * // Count the number of Transactions\n   * const count = await prisma.transaction.count({\n   *   where: {\n   *     // ... the filter for the Transactions we want to count\n   *   }\n   * })\n  **/\n  count<T extends TransactionCountArgs>(\n    args?: Prisma.Subset<T, TransactionCountArgs>,\n  ): Prisma.PrismaPromise<\n    T extends runtime.Types.Utils.Record<'select', any>\n      ? T['select'] extends true\n        ? number\n        : Prisma.GetScalarType<T['select'], TransactionCountAggregateOutputType>\n      : number\n  >\n\n  /**\n   * Allows you to perform aggregations operations on a Transaction.\n   * Note, that providing `undefined` is treated as the value not being there.\n   * Read more here: https://pris.ly/d/null-undefined\n   * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n   * @example\n   * // Ordered by age ascending\n   * // Where email contains prisma.io\n   * // Limited to the 10 users\n   * const aggregations = await prisma.user.aggregate({\n   *   _avg: {\n   *     age: true,\n   *   },\n   *   where: {\n   *     email: {\n   *       contains: \"prisma.io\",\n   *     },\n   *   },\n   *   orderBy: {\n   *     age: \"asc\",\n   *   },\n   *   take: 10,\n   * })\n  **/\n  aggregate<T extends TransactionAggregateArgs>(args: Prisma.Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>\n\n  /**\n   * Group by Transaction.\n   * Note, that providing `undefined` is treated as the value not being there.\n   * Read more here: https://pris.ly/d/null-undefined\n   * @param {TransactionGroupByArgs} args - Group by arguments.\n   * @example\n   * // Group by city, order by createdAt, get count\n   * const result = await prisma.user.groupBy({\n   *   by: ['city', 'createdAt'],\n   *   orderBy: {\n   *     createdAt: true\n   *   },\n   *   _count: {\n   *     _all: true\n   *   },\n   * })\n   * \n  **/\n  groupBy<\n    T extends TransactionGroupByArgs,\n    HasSelectOrTake extends Prisma.Or<\n      Prisma.Extends<'skip', Prisma.Keys<T>>,\n      Prisma.Extends<'take', Prisma.Keys<T>>\n    >,\n    OrderByArg extends Prisma.True extends HasSelectOrTake\n      ? { orderBy: TransactionGroupByArgs['orderBy'] }\n      : { orderBy?: TransactionGroupByArgs['orderBy'] },\n    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,\n    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,\n    ByValid extends Prisma.Has<ByFields, OrderFields>,\n    HavingFields extends Prisma.GetHavingFields<T['having']>,\n    HavingValid extends Prisma.Has<ByFields, HavingFields>,\n    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,\n    InputErrors extends ByEmpty extends Prisma.True\n    ? `Error: \"by\" must not be empty.`\n    : HavingValid extends Prisma.False\n    ? {\n        [P in HavingFields]: P extends ByFields\n          ? never\n          : P extends string\n          ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n          : [\n              Error,\n              'Field ',\n              P,\n              ` in \"having\" needs to be provided in \"by\"`,\n            ]\n      }[HavingFields]\n    : 'take' extends Prisma.Keys<T>\n    ? 'orderBy' extends Prisma.Keys<T>\n      ? ByValid extends Prisma.True\n        ? {}\n        : {\n            [P in OrderFields]: P extends ByFields\n              ? never\n              : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n          }[OrderFields]\n      : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n    : 'skip' extends Prisma.Keys<T>\n    ? 'orderBy' extends Prisma.Keys<T>\n      ? ByValid extends Prisma.True\n        ? {}\n        : {\n            [P in OrderFields]: P extends ByFields\n              ? never\n              : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n          }[OrderFields]\n      : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n    : ByValid extends Prisma.True\n    ? {}\n    : {\n        [P in OrderFields]: P extends ByFields\n          ? never\n          : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n      }[OrderFields]\n  >(args: Prisma.SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n/**\n * Fields of the Transaction model\n */\nreadonly fields: TransactionFieldRefs;\n}\n\n/**\n * The delegate class that acts as a \"Promise-like\" for Transaction.\n * Why is this prefixed with `Prisma__`?\n * Because we want to prevent naming conflicts as mentioned in\n * https://github.com/prisma/prisma-client-js/issues/707\n */\nexport interface Prisma__TransactionClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n  readonly [Symbol.toStringTag]: \"PrismaPromise\"\n  /**\n   * Attaches callbacks for the resolution and/or rejection of the Promise.\n   * @param onfulfilled The callback to execute when the Promise is resolved.\n   * @param onrejected The callback to execute when the Promise is rejected.\n   * @returns A Promise for the completion of which ever callback is executed.\n   */\n  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>\n  /**\n   * Attaches a callback for only the rejection of the Promise.\n   * @param onrejected The callback to execute when the Promise is rejected.\n   * @returns A Promise for the completion of the callback.\n   */\n  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>\n  /**\n   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n   * resolved value cannot be modified from the callback.\n   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n   * @returns A Promise for the completion of the callback.\n   */\n  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>\n}\n\n\n\n\n/**\n * Fields of the Transaction model\n */\nexport interface TransactionFieldRefs {\n  readonly id: Prisma.FieldRef<\"Transaction\", 'String'>\n  readonly paymentRef: Prisma.FieldRef<\"Transaction\", 'String'>\n  readonly amount: Prisma.FieldRef<\"Transaction\", 'Float'>\n  readonly phone: Prisma.FieldRef<\"Transaction\", 'String'>\n  readonly status: Prisma.FieldRef<\"Transaction\", 'txnStatus'>\n  readonly mpesaRef: Prisma.FieldRef<\"Transaction\", 'String'>\n  readonly checkoutRequestId: Prisma.FieldRef<\"Transaction\", 'String'>\n  readonly createdAt: Prisma.FieldRef<\"Transaction\", 'DateTime'>\n  readonly updatedAt: Prisma.FieldRef<\"Transaction\", 'DateTime'>\n}\n    \n\n// Custom InputTypes\n/**\n * Transaction findUnique\n */\nexport type TransactionFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {\n  /**\n   * Select specific fields to fetch from the Transaction\n   */\n  select?: Prisma.TransactionSelect<ExtArgs> | null\n  /**\n   * Omit specific fields from the Transaction\n   */\n  omit?: Prisma.TransactionOmit<ExtArgs> | null\n  /**\n   * Filter, which Transaction to fetch.\n   */\n  where: Prisma.TransactionWhereUniqueInput\n}\n\n/**\n * Transaction findUniqueOrThrow\n */\nexport type TransactionFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {\n  /**\n   * Select specific fields to fetch from the Transaction\n   */\n  select?: Prisma.TransactionSelect<ExtArgs> | null\n  /**\n   * Omit specific fields from the Transaction\n   */\n  omit?: Prisma.TransactionOmit<ExtArgs> | null\n  /**\n   * Filter, which Transaction to fetch.\n   */\n  where: Prisma.TransactionWhereUniqueInput\n}\n\n/**\n * Transaction findFirst\n */\nexport type TransactionFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {\n  /**\n   * Select specific fields to fetch from the Transaction\n   */\n  select?: Prisma.TransactionSelect<ExtArgs> | null\n  /**\n   * Omit specific fields from the Transaction\n   */\n  omit?: Prisma.TransactionOmit<ExtArgs> | null\n  /**\n   * Filter, which Transaction to fetch.\n   */\n  where?: Prisma.TransactionWhereInput\n  /**\n   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n   * \n   * Determine the order of Transactions to fetch.\n   */\n  orderBy?: Prisma.TransactionOrderByWithRelationInput | Prisma.TransactionOrderByWithRelationInput[]\n  /**\n   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n   * \n   * Sets the position for searching for Transactions.\n   */\n  cursor?: Prisma.TransactionWhereUniqueInput\n  /**\n   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n   * \n   * Take `Â±n` Transactions from the position of the cursor.\n   */\n  take?: number\n  /**\n   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n   * \n   * Skip the first `n` Transactions.\n   */\n  skip?: number\n  /**\n   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n   * \n   * Filter by unique combinations of Transactions.\n   */\n  distinct?: Prisma.TransactionScalarFieldEnum | Prisma.TransactionScalarFieldEnum[]\n}\n\n/**\n * Transaction findFirstOrThrow\n */\nexport type TransactionFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {\n  /**\n   * Select specific fields to fetch from the Transaction\n   */\n  select?: Prisma.TransactionSelect<ExtArgs> | null\n  /**\n   * Omit specific fields from the Transaction\n   */\n  omit?: Prisma.TransactionOmit<ExtArgs> | null\n  /**\n   * Filter, which Transaction to fetch.\n   */\n  where?: Prisma.TransactionWhereInput\n  /**\n   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n   * \n   * Determine the order of Transactions to fetch.\n   */\n  orderBy?: Prisma.TransactionOrderByWithRelationInput | Prisma.TransactionOrderByWithRelationInput[]\n  /**\n   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n   * \n   * Sets the position for searching for Transactions.\n   */\n  cursor?: Prisma.TransactionWhereUniqueInput\n  /**\n   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n   * \n   * Take `Â±n` Transactions from the position of the cursor.\n   */\n  take?: number\n  /**\n   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n   * \n   * Skip the first `n` Transactions.\n   */\n  skip?: number\n  /**\n   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n   * \n   * Filter by unique combinations of Transactions.\n   */\n  distinct?: Prisma.TransactionScalarFieldEnum | Prisma.TransactionScalarFieldEnum[]\n}\n\n/**\n * Transaction findMany\n */\nexport type TransactionFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {\n  /**\n   * Select specific fields to fetch from the Transaction\n   */\n  select?: Prisma.TransactionSelect<ExtArgs> | null\n  /**\n   * Omit specific fields from the Transaction\n   */\n  omit?: Prisma.TransactionOmit<ExtArgs> | null\n  /**\n   * Filter, which Transactions to fetch.\n   */\n  where?: Prisma.TransactionWhereInput\n  /**\n   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n   * \n   * Determine the order of Transactions to fetch.\n   */\n  orderBy?: Prisma.TransactionOrderByWithRelationInput | Prisma.TransactionOrderByWithRelationInput[]\n  /**\n   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n   * \n   * Sets the position for listing Transactions.\n   */\n  cursor?: Prisma.TransactionWhereUniqueInput\n  /**\n   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n   * \n   * Take `Â±n` Transactions from the position of the cursor.\n   */\n  take?: number\n  /**\n   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n   * \n   * Skip the first `n` Transactions.\n   */\n  skip?: number\n  distinct?: Prisma.TransactionScalarFieldEnum | Prisma.TransactionScalarFieldEnum[]\n}\n\n/**\n * Transaction create\n */\nexport type TransactionCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {\n  /**\n   * Select specific fields to fetch from the Transaction\n   */\n  select?: Prisma.TransactionSelect<ExtArgs> | null\n  /**\n   * Omit specific fields from the Transaction\n   */\n  omit?: Prisma.TransactionOmit<ExtArgs> | null\n  /**\n   * The data needed to create a Transaction.\n   */\n  data: Prisma.XOR<Prisma.TransactionCreateInput, Prisma.TransactionUncheckedCreateInput>\n}\n\n/**\n * Transaction createMany\n */\nexport type TransactionCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {\n  /**\n   * The data used to create many Transactions.\n   */\n  data: Prisma.TransactionCreateManyInput | Prisma.TransactionCreateManyInput[]\n  skipDuplicates?: boolean\n}\n\n/**\n * Transaction update\n */\nexport type TransactionUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {\n  /**\n   * Select specific fields to fetch from the Transaction\n   */\n  select?: Prisma.TransactionSelect<ExtArgs> | null\n  /**\n   * Omit specific fields from the Transaction\n   */\n  omit?: Prisma.TransactionOmit<ExtArgs> | null\n  /**\n   * The data needed to update a Transaction.\n   */\n  data: Prisma.XOR<Prisma.TransactionUpdateInput, Prisma.TransactionUncheckedUpdateInput>\n  /**\n   * Choose, which Transaction to update.\n   */\n  where: Prisma.TransactionWhereUniqueInput\n}\n\n/**\n * Transaction updateMany\n */\nexport type TransactionUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {\n  /**\n   * The data used to update Transactions.\n   */\n  data: Prisma.XOR<Prisma.TransactionUpdateManyMutationInput, Prisma.TransactionUncheckedUpdateManyInput>\n  /**\n   * Filter which Transactions to update\n   */\n  where?: Prisma.TransactionWhereInput\n  /**\n   * Limit how many Transactions to update.\n   */\n  limit?: number\n}\n\n/**\n * Transaction upsert\n */\nexport type TransactionUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {\n  /**\n   * Select specific fields to fetch from the Transaction\n   */\n  select?: Prisma.TransactionSelect<ExtArgs> | null\n  /**\n   * Omit specific fields from the Transaction\n   */\n  omit?: Prisma.TransactionOmit<ExtArgs> | null\n  /**\n   * The filter to search for the Transaction to update in case it exists.\n   */\n  where: Prisma.TransactionWhereUniqueInput\n  /**\n   * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.\n   */\n  create: Prisma.XOR<Prisma.TransactionCreateInput, Prisma.TransactionUncheckedCreateInput>\n  /**\n   * In case the Transaction was found with the provided `where` argument, update it with this data.\n   */\n  update: Prisma.XOR<Prisma.TransactionUpdateInput, Prisma.TransactionUncheckedUpdateInput>\n}\n\n/**\n * Transaction delete\n */\nexport type TransactionDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {\n  /**\n   * Select specific fields to fetch from the Transaction\n   */\n  select?: Prisma.TransactionSelect<ExtArgs> | null\n  /**\n   * Omit specific fields from the Transaction\n   */\n  omit?: Prisma.TransactionOmit<ExtArgs> | null\n  /**\n   * Filter which Transaction to delete.\n   */\n  where: Prisma.TransactionWhereUniqueInput\n}\n\n/**\n * Transaction deleteMany\n */\nexport type TransactionDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {\n  /**\n   * Filter which Transactions to delete\n   */\n  where?: Prisma.TransactionWhereInput\n  /**\n   * Limit how many Transactions to delete.\n   */\n  limit?: number\n}\n\n/**\n * Transaction without action\n */\nexport type TransactionDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {\n  /**\n   * Select specific fields to fetch from the Transaction\n   */\n  select?: Prisma.TransactionSelect<ExtArgs> | null\n  /**\n   * Omit specific fields from the Transaction\n   */\n  omit?: Prisma.TransactionOmit<ExtArgs> | null\n}\n"]}